/*
 * @(#)XmlAllStopsParser.java	1.0	05/31/09
 *
 * Copyright 2009 Canabang Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms is not permitted without the written
 * consent from Canabang Inc.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.canabang.genietext.transit.model.io;

import com.canabang.genietext.core.model.io.xml.XmlParser;
import com.canabang.genietext.core.model.io.xml.XmlProperties;
import com.canabang.genietext.transit.model.processor.dbase.DottedIntersection;
import com.canabang.genietext.transit.model.processor.dbase.Intersection;
import com.canabang.genietext.transit.model.processor.dbase.SlashedIntersection;
import com.canabang.genietext.transit.model.processor.dbase.Station;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Map;
import java.util.Set;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;


/**
 * Parses a "allstops.xml" file generated by the Ottawa Travel Planner - OC Data stop analysis
 * tool written by Michael Hurts. Gets a list of stops and their corresponding buses that arrive
 * at those locations.
 *
 * @author rhaq
 * @version 1.00 2009-05-31 Initial submission.
 */
public class XmlAllStopsParser extends XmlParser
{
	/** The average number of stops that any given location has. */
	private static final int DEFAULT_NUMBER_STOPS = 2;

	/** Tag name that specifies what type of bus arrives at stop. */
	private static final String ROUTE_KEY = "route";

	/** Tag name that specifies the number of the bus that arrives at the stop. */
	private static final String ROUTE_NUMBER_ATTRIBUTE = "number";

	/** Tag name to give you all the route data for a certain location. */
	private static final String ROUTES_KEY = "routes";

	/** Gives you the name of the stop (ie: street names). */
	private static final String STOP_NAME_ATTRIBUTE = "name";

	/** Gives you the 4-digit bus stop number. */
	private static final String STOP_NUMBER_ATTRIBUTE = "number";

	/** A stop location's tag. */
	private static final String STOP_TAG = "stop";

	/** Maps a location to a set of stops that it possesses. */
	private Map< Intersection, Set<Station> > locations;


	/**
	 * Creates an instance of this class so that a stop database XML file may be parsed.
	 * @throws ParserConfigurationException If there is any problem setting up the XML parser.
	 */
	public XmlAllStopsParser() throws ParserConfigurationException
	{
		super();
		locations = new Hashtable< Intersection, Set<Station> >();
	}


	/**
	 * Parses the specified file and retrieves the location data stored within.
	 * @param file The file to parse for the location data.
	 * @return The location data stored in the file.
	 * @throws SAXException If there are any problems parsing the XML file associated with the transit service.
	 * @throws IOException If there is a problem accessing the resource file for the transit service.
	 */
	public Map< Intersection, Set<Station> > parse(InputStream file) throws SAXException, IOException
	{
		// parse using builder to get DOM representation of the XML file
		dom = db.parse(file);
		parseDocument();

		return locations;
	}


	/**
	 * Parses the document and populates the locations data.
	 */
	private void parseDocument()
	{
		// get the root element: smsServices
		Element root = dom.getDocumentElement();

		NodeList stops = root.getElementsByTagName(STOP_TAG);

		for (int i = 0; i < stops.getLength(); i++)
		{
			try {
				parseStop( getElement(stops, i) );
			}

			catch (ArrayIndexOutOfBoundsException ex)
			{
			}

			catch (NumberFormatException ex)
			{
			}
		}
	}


	/**
	 * Parses the route number data stored within the specified element and places it in the
	 * specified station object.
	 * @param route The route data to parse.
	 * @param stop The station data to place the route data into.
	 */
	private void parseRoute(Element route, Station stop)
	{
		int busNumber = Integer.parseInt( route.getAttribute(ROUTE_NUMBER_ATTRIBUTE) );
		stop.addBus(busNumber);
	}


	/**
	 * Parses the stop data specified.
	 * @param stop The stop data to parse and populate the locations data for.
	 */
	private void parseStop(Element stop)
	{
		String stopName = stop.getAttribute(STOP_NAME_ATTRIBUTE);
		stopName = stopName.replace(DottedIntersection.DELIMITER, XmlProperties.BLANK);

		Intersection i = new SlashedIntersection(stopName);

		int stopNumber = Integer.parseInt( stop.getAttribute(STOP_NUMBER_ATTRIBUTE) );
		Station s = new Station(stopNumber);
		parseStopRoutes(stop, s);

		if ( locations.containsKey(i) ) // we need to add another stop to this
			locations.get(i).add(s);

		else
		{
			Set<Station> stops = new HashSet<Station>(DEFAULT_NUMBER_STOPS);
			stops.add(s);
			locations.put(i, stops);
		}
	}


	/**
	 * Parses the route data stored within the stop tag specified and places the information
	 * within the station object.
	 * @param stopData The stop data containing the route data.
	 * @param stop The station object to place the route data into.
	 */
	private void parseStopRoutes(Element stopData, Station stop)
	{
		NodeList routesList = stopData.getElementsByTagName(ROUTES_KEY); // gets you all <routes> tags

		for (int i = 0; i < routesList.getLength(); i++)
		{
			Element allRoutes = getElement(routesList, i); // a <routes> tag
			NodeList routes = allRoutes.getElementsByTagName(ROUTE_KEY); // all <route> tags

			for (int j = 0; j < routes.getLength(); j++)
				parseRoute( getElement(routes, j), stop );
		}
	}
}